#pragma config(Sensor, in1,    gBase1,         sensorGyro)
#pragma config(Sensor, in2,    gLift2,         sensorGyro)
#pragma config(Sensor, in3,    gMobile3,       sensorGyro)
#pragma config(Sensor, in4,    gChainbar4,     sensorGyro)
#pragma config(Sensor, in5,    lMobile,        sensorLineFollower)
#pragma config(Sensor, in6,    lRollers,       sensorLineFollower)
#pragma config(Sensor, in7,    ,               sensorGyro)
#pragma config(Sensor, in8,    ,               sensorGyro)
#pragma config(Sensor, dgtl1,  jAuton1,        sensorTouch)
#pragma config(Sensor, dgtl2,  jAuton2,        sensorTouch)
#pragma config(Sensor, dgtl3,  jAuton4,        sensorTouch)
#pragma config(Sensor, dgtl4,  jAuton8,        sensorTouch)
#pragma config(Sensor, dgtl7,  qRollers13,     sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  qRightDrive12,  sensorQuadEncoder)
#pragma config(Sensor, dgtl11, qLeftDrive11,   sensorQuadEncoder)
#pragma config(Motor,  port1,           mRightTop,     tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           mRightBottom,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           mMobileRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           mLiftRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mClaw,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           mChainbar,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           mLiftLeft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           mMobileLeft,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           mLeftBottom,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          mLeftTop,      tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "SPuser.c"

int moveDir;
int liftDir;
int turnDir;
int mobileDir;
int chainbarDir;
int autonNumber;
int timer;

int oldQuadValue;
int disDiff;
float CMV;
float NMV;
float motDiff;

void mobile(int pwr, int angle){ //0 in, -900 out,
	while(SensorValue[gLift2] < liftMobileAngle){
		motor[mLiftLeft] = 127;
		motor[mLiftRight] = 127;
	}
	motor[mLiftLeft] = 0;
	motor[mLiftRight] = 0;
	timer = nSysTime;
	if(angle < SensorValue[gMobile3]){
		mobileDir = 1;
	}
	else{
		mobileDir = -1;
	}
	while(((mobileDir == 1 && SensorValue[gMobile3] >= angle) || (mobileDir == -1 && SensorValue[gMobile3] <= angle)) && nSysTime - timer <= 1000){
		motor[mMobileLeft] = pwr*mobileDir;
		motor[mMobileRight] = pwr*mobileDir;
	}
	motor[mMobileLeft] = 0;
	motor[mMobileRight] = 0;
}

void dr4b(int pwr, int angle){
	if(angle > SensorValue[gLift2]){
		liftDir = 1;
	}
	else{
		liftDir = -1;
	}
	while((liftDir == 1 && SensorValue[gLift2] <= angle) || (liftDir == -1 && SensorValue[gLift2] >= angle)){
		motor[mLiftLeft] = pwr*liftDir;
		motor[mLiftRight] = pwr*liftDir;
	}
	motor[mLiftLeft] = 0;
	motor[mLiftRight] = 0;
}

void chainbar(int angle){
	if(angle > SensorValue[gChainbar4]){
		chainbarDir = 1;
	}
	else{
		chainbarDir = -1;
	}
	while((chainbarDir == 1 && SensorValue[gChainbar4] <= angle) || (chainbarDir == -1 && SensorValue[gChainbar4] >= angle)){
		motor[mChainbar] = 127*chainbarDir;
	}
	motor[mChainbar] = 0;
}

void turnG(int angle,int pwr){
	if(angle < 0){
		turnDir = -1;
	}
	else{
		turnDir = 1;
	}
	while((angle < 0 && SensorValue[gBase1] > angle) || (angle > 0 && SensorValue[gBase1] < angle)){
		lDrive(pwr*turnDir);
		rDrive(pwr*-turnDir);
	}
	rDrive(0);
	lDrive(0);
	reset(0);
}

void turnQ(int dis, int pwr){
	if(dis > 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while((dis < 0 && SensorValue[qLeftDrive11] >= dis && SensorValue[qRightDrive12] <= -dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] <= dis && SensorValue[qRightDrive12] >= -dis)){
		lDrive(pwr*moveDir);
		rDrive(pwr*-moveDir);
	}
	lDrive(0);
	rDrive(0);
	reset(0);
}

void drive(int pwr, int dis){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while((dis < 0 && SensorValue[qLeftDrive11] >= dis && SensorValue[qRightDrive12] <= -dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] <= dis && SensorValue[qRightDrive12] >= -dis)){
		lDrive(pwr*moveDir);
		rDrive(pwr*moveDir);
	}
	lDrive(0);
	rDrive(0);
	reset(0);
}

void driveMobile(int pwr, int dis){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while(((dis > 0 && SensorValue[qLeftDrive11] <= -dis && SensorValue[qRightDrive12] >= dis) ||
		(dis < 0 && SensorValue[qLeftDrive11] >= -dis && SensorValue[qRightDrive12] <= dis)) && (SensorValue[lMobile] >= 2000)){
		lDrive(pwr*moveDir);
		rDrive(pwr*moveDir);
	}
	lDrive(0);
	rDrive(0);
	reset(0);
}

void PIDmove(int dis, int pwr){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	CMV = pwr*moveDir;
	NMV = CMV;
	timer = nSysTime;
	while((dis < 0 && SensorValue[qLeftDrive11] <= -dis && SensorValue[qRightDrive12] >= dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] >= -dis && SensorValue[qRightDrive12] <= dis)){
		if(nSysTime - timer >= 100 && SensorValue[qLeftDrive11] >= dis*.75){
			disDiff = -(SensorValue[qLeftDrive11] - oldQuadValue);
			motDiff = (pwr*1.0-30)/(dis*.25)*disDiff;
			NMV = CMV - motDiff;
			oldQuadValue = SensorValue[qLeftDrive11];
			CMV = NMV;
			timer = nSysTime;
		}
		lDrive(NMV);
		rDrive(NMV);
	}
	reset(0);
	lDrive(0);
	rDrive(0);
	CMV = 0;
	NMV = 0;
	motDiff = 0;
	oldQuadValue = 0;
	motDiff = 0;
}

void PIDmoveMobile(int dis,int pwr){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	oldQuadValue = SensorValue[qLeftDrive11];
	CMV = pwr*moveDir;
	timer = nSysTime;
	while(((dis < 0 && SensorValue[qLeftDrive11] <= -dis && SensorValue[qRightDrive12] >= dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] >= -dis && SensorValue[qRightDrive12] <= dis)) && (SensorValue[lMobile] >= 2000)){
		if(nSysTime - timer >= 100 && SensorValue[qLeftDrive11] >= dis*.75){
			disDiff = -(SensorValue[qLeftDrive11] - oldQuadValue);
			motDiff = (pwr*1.0-30)/dis*disDiff;
			NMV = CMV - motDiff;
			oldQuadValue = SensorValue[qLeftDrive11];
			CMV = NMV;
			timer = nSysTime;
		}
		lDrive(NMV);
		rDrive(NMV);
	}
	reset(0);
	lDrive(0);
	rDrive(0);
	CMV = 0;
	NMV = 0;
	motDiff = 0;
	oldQuadValue = 0;
	motDiff = 0;
}

void PIDturnG(int angle, int pwr){
	if(angle < 0){
		turnDir = -1;
	}
	else{
		turnDir = 1;
	}
	oldQuadValue = SensorValue[qLeftDrive11];
	CMV = pwr*moveDir;
	timer = nSysTime;
	while((angle < 0 && SensorValue[gBase1] > angle) || (angle > 0 && SensorValue[gBase1] < angle)){
		if(nSysTime - timer >= 100 && SensorValue[qLeftDrive11] >= angle*.75){
			disDiff = -(SensorValue[qLeftDrive11] - oldQuadValue);
			motDiff = (pwr*1.0-30)/(angle*.25)*disDiff;
			NMV = CMV - motDiff;
			oldQuadValue = SensorValue[qLeftDrive11];
			CMV = NMV;
			timer = nSysTime;
		}
		lDrive(NMV);
		rDrive(NMV);
	}
	lDrive(0);
	rDrive(0);
	CMV = 0;
	NMV = 0;
	motDiff = 0;
	oldQuadValue = 0;
	motDiff = 0;
	reset(0);
}

void PIDturnQ(int dis, int pwr){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	oldQuadValue = SensorValue[qLeftDrive11];
	CMV = pwr*moveDir;
	timer = nSysTime;
	while((dis < 0 && SensorValue[qLeftDrive11] <= -dis && SensorValue[qRightDrive12] >= dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] >= -dis && SensorValue[qRightDrive12] <= dis)){
		if(nSysTime - timer >= 100 && SensorValue[qLeftDrive11] >= dis*.75){
			disDiff = -(SensorValue[qLeftDrive11] - oldQuadValue);
			motDiff = (pwr*1.0-30)/(dis*.25)*disDiff;
			NMV = CMV - motDiff;
			oldQuadValue = SensorValue[qLeftDrive11];
			CMV = NMV;
			timer = nSysTime;
		}
		lDrive(NMV);
		rDrive(NMV);
	}
	lDrive(0);
	rDrive(0);
	CMV = 0;
	NMV = 0;
	motDiff = 0;
	oldQuadValue = 0;
	motDiff = 0;
	reset(0);
}

void auton1(){ //stationary
	motor[mClaw] = 30;
	dr4b(127,300);
	motor[mLiftLeft] = 30;
	motor[mLiftRight] = 30;
	drive(60,600);
	dr4b(50,250);
	motor[mClaw] = -60;
	dr4b(100,300);
	motor[mLiftLeft] = 30;
	motor[mLiftRight] = 30;
	motor[mClaw] = 0;
	drive(70,-300);
	dr4b(50,100);
	//lift up
	//drive forward
	//drop lift
	//rollers reverse
	//move lift up
	//stop rollers
	//back up
}

void auton2(){ //stationary
	motor[mClaw] = 30;
	dr4b(127,300);
	motor[mLiftLeft] = 30;
	motor[mLiftRight] = 30;
	drive(60,850);
	dr4b(50,250);
	motor[mClaw] = -60;
	dr4b(100,300);
	motor[mLiftLeft] = 30;
	motor[mLiftRight] = 30;
	motor[mClaw] = 0;
	drive(70,-300);
	dr4b(50,100);
	//lift up
	//drive forward
	//drop lift
	//rollers reverse
	//move lift up
	//stop rollers
	//back up
}

void auton3(){ //Mobile left 20
	//mobile out
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn towards center
	//forward
	//turn towards corner
	//forward
	//lift up
	//mobile out
	//back up
}

void auton4(){ //mobile right 20
	//mobile out
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn towards center
	//forward
	//turn towards corner
	//forward
	//lift up
	//mobile out
	//back up
}

void pragmaSkills(){ //Programming Skills
	//refer to sheet
}

void autonTest(){
}

void autonSelecter(){
	if(SensorValue[jAuton1] == true){
		autonNumber += 1;
	}
	if(SensorValue[jAuton2] == true){
		autonNumber += 2;
	}
	if(SensorValue[jAuton4] == true){
		autonNumber += 4;
	}
	if(SensorValue[jAuton8] == true){
		autonNumber += 8;
	}
	switch(autonNumber){
	case 0: //none
		autonTest();
		break;
	case 1: //Stationary close (center)
		auton1();
		break;
	case 2: ////Stationary far (wings)
		auton2();
		break;
	case 3: //Mobile Left 20
		auton3();
		break;
	case 4: //Mobile Right 20
		break;
	case 15: //Skills
		pragmaSkills();
		break;
	default:
		break;
	}
	//Stationary
	//Mobile Left 20: 1 Cone, 4 Cone
	//Mobile Right 20: 1 Cone, 4 Cone
	//Mobile Left 10: 1 Cone, 4 Cone
	//Mobile Right 10: 1 Cone, 4 Cone
	//Programming skills
}

void pre_auton(){
	bStopTasksBetweenModes = true;
}

task autonomous(){
	autonNumber = 0;
	reset(0);
	autonSelecter();
}
