#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    gBase1,         sensorGyro)
#pragma config(Sensor, in2,    pLift2,         sensorPotentiometer)
#pragma config(Sensor, in3,    gMobile3,       sensorGyro)
#pragma config(Sensor, in5,    lMobile,        sensorLineFollower)
#pragma config(Sensor, in7,    p4Bar,          sensorPotentiometer)
#pragma config(Sensor, dgtl1,  jAuton1,        sensorTouch)
#pragma config(Sensor, dgtl2,  jAuton2,        sensorTouch)
#pragma config(Sensor, dgtl3,  jAuton4,        sensorTouch)
#pragma config(Sensor, dgtl4,  jAuton8,        sensorTouch)
#pragma config(Sensor, dgtl9,  qRightDrive12,  sensorQuadEncoder)
#pragma config(Sensor, dgtl11, qLeftDrive11,   sensorQuadEncoder)
#pragma config(Motor,  port1,           mClaw,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           mLift,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           mRightTop,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           mRightBack,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           mRightFront,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           mLeftFront,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           mLeftBack,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           mLeftTop,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           mMobile,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          mChainbar,     tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"



#include "SPuser.c"



int x;
int lastDis;
int moveDir;
int liftDir;
int turnDir;
int mobileDir;
int chainbarDir;
int timer;

int oldQuadValue;
int disDiff;
float CMV;
float NMV;
float motDiff;

void mobile(int pwr, int angle){ //0 in, -900 out,
	while(SensorValue[pLift2] < liftMobileAngle){
		motor[mLift] = 127;
	}
	motor[mLift] = 0;
	timer = nSysTime;
	if(angle < SensorValue[gMobile3]){
		mobileDir = 1;
	}
	else{
		mobileDir = -1;
	}
	while(((mobileDir == 1 && SensorValue[gMobile3] >= angle) || (mobileDir == -1 && SensorValue[gMobile3] <= angle)) && nSysTime - timer <= 2500){
		motor[mMobile] = pwr*mobileDir;
	}
	motor[mMobile] = 0;

}

void dr4b(int pwr, int angle){
	if(angle > SensorValue[pLift2]){
		liftDir = 1;
	}
	else{
		liftDir = -1;
	}
	while(((liftDir == 1 && SensorValue[pLift2] <= angle) || (liftDir == -1 && SensorValue[pLift2] >= angle)) && !(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 1)){
		motor[mLift] = pwr*liftDir;
	}
	motor[mLift] = 0;
}

void chainbar(int angle){
	if(angle > SensorValue[p4Bar]){
		chainbarDir = 1;
	}
	else{
		chainbarDir = -1;
	}
	while((chainbarDir == 1 && SensorValue[p4Bar] <= angle) || (chainbarDir == -1 && SensorValue[p4Bar] >= angle)){
		motor[mChainbar] = 127*chainbarDir;
	}
	motor[mChainbar] = 0;
}

void turnG(int pwr,int angle){
	if(angle < 0){
		turnDir = -1;
	}
	else{
		turnDir = 1;
	}
	while((angle < 0 && SensorValue[gBase1] > angle) || (angle > 0 && SensorValue[gBase1] < angle)){
		lDrive(pwr*-turnDir);
		rDrive(pwr*turnDir);
	}
	rDrive(0);
	lDrive(0);
	reset(0);
}

void turnQ(int dis, int pwr){
	if(dis > 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while((dis < 0 && SensorValue[qLeftDrive11] >= dis && SensorValue[qRightDrive12] <= -dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] <= dis && SensorValue[qRightDrive12] >= -dis)){
		lDrive(pwr*moveDir);
		rDrive(pwr*-moveDir);
	}
	lDrive(0);
	rDrive(0);
	reset(0);
}

void drive(int pwr, int dis){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while((dis < 0 && SensorValue[qLeftDrive11] >= dis && SensorValue[qRightDrive12] <= -dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] <= dis && SensorValue[qRightDrive12] >= -dis)){
		lDrive(pwr*moveDir);
		rDrive(pwr*moveDir);
	}
	lDrive(0);
	rDrive(0);
	lastDis = SensorValue[qLeftDrive11];
	reset(0);

}

void driveTime(int pwr, int dis, int time){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	timer = nSysTime;
	while(((dis < 0 && SensorValue[qLeftDrive11] >= dis && SensorValue[qRightDrive12] <= -dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] <= dis && SensorValue[qRightDrive12] >= -dis)) && (nSysTime - timer <= time)){
		lDrive(pwr*moveDir);
		rDrive(pwr*moveDir);
	}
	lDrive(0);
	rDrive(0);
	lastDis = SensorValue[qLeftDrive11];
	reset(0);

}

void driveMobile(int pwr, int dis){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while(((dis < 0 && SensorValue[qLeftDrive11] >= dis && SensorValue[qRightDrive12] <= -dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] <= dis && SensorValue[qRightDrive12] >= -dis)) && (SensorValue[lMobile] >= 2000)){
		lDrive(pwr*moveDir);
		rDrive(pwr*moveDir);
	}
	lDrive(0);
	rDrive(0);
	lastDis = SensorValue[qLeftDrive11];
	reset(0);

}

void PIDmove(int pwr, int dis){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	CMV = pwr*moveDir;
	NMV = CMV;
	timer = nSysTime;
	while((dis < 0 && SensorValue[qLeftDrive11] <= -dis && SensorValue[qRightDrive12] >= dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] >= -dis && SensorValue[qRightDrive12] <= dis)){
		if(nSysTime - timer >= 100 && SensorValue[qLeftDrive11] >= dis*.75){
			disDiff = -(SensorValue[qLeftDrive11] - oldQuadValue);
			motDiff = (pwr*1.0-30)/(dis*.25)*disDiff;
			NMV = CMV - motDiff;
			oldQuadValue = SensorValue[qLeftDrive11];
			CMV = NMV;
			timer = nSysTime;
		}
		lDrive(NMV);
		rDrive(NMV);
	}
	reset(0);
	lDrive(0);
	rDrive(0);
	CMV = 0;
	NMV = 0;
	motDiff = 0;
	oldQuadValue = 0;
	motDiff = 0;
	lastDis = SensorValue[qLeftDrive11];
}

void PIDmoveMobile(int pwr,int dis){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	oldQuadValue = SensorValue[qLeftDrive11];
	CMV = pwr*moveDir;
	timer = nSysTime;
	while(((dis < 0 && SensorValue[qLeftDrive11] <= -dis && SensorValue[qRightDrive12] >= dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] >= -dis && SensorValue[qRightDrive12] <= dis)) && (SensorValue[lMobile] >= 2000)){
		if(nSysTime - timer >= 100 && SensorValue[qLeftDrive11] >= dis*.75){
			disDiff = -(SensorValue[qLeftDrive11] - oldQuadValue);
			motDiff = (pwr*1.0-30)/dis*disDiff;
			NMV = CMV - motDiff;
			oldQuadValue = SensorValue[qLeftDrive11];
			CMV = NMV;
			timer = nSysTime;
		}
		lDrive(NMV);
		rDrive(NMV);
	}
	reset(0);
	lDrive(0);
	rDrive(0);
	CMV = 0;
	NMV = 0;
	motDiff = 0;
	oldQuadValue = 0;
	motDiff = 0;
	lastDis = SensorValue[qLeftDrive11];
}

float gkP = 0.35;
float gkI = 0.08;
float gkD = 0.007;
float gPower = 30;
float lastPower[10] = {0,0,0,0,0,0,0,0,0,0};
int lastAngle[3] = {0,0,0};
//gyro-based PID turning
void PIDturnG(float pwr, int angle){
	int gIntegral = 0;
	int gDerivative = 0;
	int prevError = angle - SensorValue[gBase1];
	while(!(abs(angle - lastAngle[2]) <= 5 && abs(angle - SensorValue[gBase1]) <= 5) && lastPower[9] != gPower){
		int error = angle - SensorValue[gBase1];
		if(error == 0 || sgn(error*angle) == -1)
			gIntegral = 0;
		if(gIntegral > 75000)
			gIntegral = 0;
	 gDerivative = error - prevError;
	 prevError = error;
	 gPower =  pwr * (gkP * error + gkI * gIntegral +  gkD * gDerivative);
	 //if(abs(gPower) < 33 && abs(gPower) > 0) gPower = sgn(gPower)*33;
	 lDrive(-PowerCap((int)gPower));
	 rDrive(PowerCap((int)gPower));
	 for(int p = 8; p >= 0; p--){
	 		lastPower[p+1] = lastPower[p];
	 }
	 for(int a = 1; a >= 0; a--){
	 		lastAngle[a+1] = lastAngle[a];
	 }
	 lastPower[0] = gPower;
	 lastAngle[0] = SensorValue[gBase1];
	 wait1Msec(20);
	}
	lDrive(0);
	rDrive(0);
	reset(0);
	gPower = 30;

//https://www.vexforum.com/index.php/6465-a-pid-controller-in-robotc/0
	/*
	if(angle < 0){
		turnDir = -1;
	}

	else{
		turnDir = 1;
	}
	oldQuadValue = SensorValue[qLeftDrive11];
	CMV = pwr*moveDir;
	timer = nSysTime;
	while((angle < 0 && SensorValue[gBase1] > angle) || (angle > 0 && SensorValue[gBase1] < angle)){
		if(nSysTime - timer >= 100 && SensorValue[qLeftDrive11] >= angle*.75){
			disDiff = -(SensorValue[qLeftDrive11] - oldQuadValue);
			motDiff = (pwr*1.0-30)/(angle*.25)*disDiff;
			NMV = CMV - motDiff;
			oldQuadValue = SensorValue[qLeftDrive11];
			CMV = NMV;
			timer = nSysTime;
		}
		lDrive(NMV);
		rDrive(NMV);
	}
	lDrive(0);
	rDrive(0);
	CMV = 0;
	NMV = 0;
	motDiff = 0;
	oldQuadValue = 0;
	motDiff = 0;
	reset(0);*/
}

void PIDturnQ(int pwr, int dis){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	oldQuadValue = SensorValue[qLeftDrive11];
	CMV = pwr*moveDir;
	timer = nSysTime;
	while((dis < 0 && SensorValue[qLeftDrive11] <= -dis && SensorValue[qRightDrive12] >= dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] >= -dis && SensorValue[qRightDrive12] <= dis)){
		if(nSysTime - timer >= 100 && SensorValue[qLeftDrive11] >= dis*.75){
			disDiff = -(SensorValue[qLeftDrive11] - oldQuadValue);
			motDiff = (pwr*1.0-30)/(dis*.25)*disDiff;
			NMV = CMV - motDiff;
			oldQuadValue = SensorValue[qLeftDrive11];
			CMV = NMV;
			timer = nSysTime;
		}
		lDrive(NMV);
		rDrive(NMV);
	}
	lDrive(0);
	rDrive(0);
	CMV = 0;
	NMV = 0;
	motDiff = 0;
	oldQuadValue = 0;
	motDiff = 0;
	reset(0);
}

int loadAngle = 215;
int potDown = 2600;
int potUp = 4095;
int stackAngs[14] = {130, 165, 200, 235, 285, 335, 385, 435, 475, 510, 565, 655, 700, 700};

void autoLoads(int num) {
	while(vexRT[Btn8U] == 1){
		waitUntil(vexRT[Btn8U] != 1);
		coneStack++;
		num++;
		if(SensorValue[pLift2] < loadAngle){
			dr4b(127, loadAngle);
		}
		while(SensorValue[p4Bar] >= potDown  && !(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 1)){
			motor[mChainbar] = -127;
		}
		motor[mChainbar] = 0;
		motor[mClaw] = 80;
		dr4b(100, loadAngle);
		motor[mChainbar] = -90;
		wait1Msec(100);
		motor[mChainbar] = 0;
		motor[mClaw] = 20;
		dr4b(127, stackAngs[num]);
		while(SensorValue[p4Bar] < potUp  && !(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 1)){
			motor[mChainbar] = 127;
		}
		motor[mChainbar] = 0;
		wait1Msec(100);
		motor[mLift] = -127;
		motor[mClaw] = -127;
		wait1Msec(200);
		motor[mLift] = 0;
		wait1Msec(200);
		motor[mClaw] = 20;
	}
	while(vexRT[Btn8D] == 1){
		waitUntil(vexRT[Btn8D] != 1);
		coneStack--;
	}
	while(vexRT[Btn8R] == 1){
		waitUntil(vexRT[Btn8R] != 1);
		if(SensorValue[pLift2] < loadAngle){
			dr4b(100, loadAngle);
		}
		while(SensorValue[p4Bar] >= potDown  && !(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 1)){
			motor[mChainbar] = -127;
		}
		motor[mChainbar] = 0;
		motor[mClaw] = 80;
		dr4b(127, loadAngle);
		motor[mChainbar] = -40;
		wait1Msec(100);
		motor[mChainbar] = 0;
		motor[mClaw] = 20;
		dr4b(127,stackAngs[num]);
		while(SensorValue[p4Bar] < potUp && !(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 1)){
			motor[mChainbar] = 127;
		}
		motor[mChainbar] = 0;
		wait1Msec(100);
		motor[mClaw] = -127;
		wait1Msec(400);
		motor[mClaw] = 20;
	}
}

//2260 = lift all Down
//2500 = Mobile Goal Clear
//3020 = Stat. clear
//2870 = On stat.

void stationLeft(){ //long stationary left
	motor[mClaw] = rollerPassive;
	motor[mChainbar] = -127;
	wait1Msec(500);
	motor[mChainbar] = 0;
	dr4b(127,3300);
	drive(90,400);
	//PIDmove(60,600);
	dr4b(127,2800);
	motor[mClaw] = -127;
	wait1Msec(100);
	dr4b(127,3000);
	motor[mClaw] = 0;
	drive(85,-50);
	dr4b(127,2500);
	turnG(100,-925);
	driveTime(127,-2200,4000);
	//lift up
	//drive forward
	//drop lift
	//rollers reverse
	//move lift up
	//stop rollers
	//back up
	//turn
	//back up to clear cones */
}

void stationRight(){ //long stationary right
	motor[mClaw] = rollerPassive;
	motor[mChainbar] = -127;
	wait1Msec(500);
	motor[mChainbar] = 0;
	dr4b(127,3300);
	drive(85,325);
	//PIDmove(60,600);
	dr4b(127,2800);
	motor[mClaw] = -127;
	wait1Msec(100);
	dr4b(127,3000);
	motor[mClaw] = 0;
	drive(85,-50);
	dr4b(127,2500);
	turnG(100,830);
	driveTime(127,-2200, 4000);
	//lift up
	//drive forward
	//drop lift
	//rollers reverse
	//move lift up
	//stop rollers
	//back up
	//turn
	//back up to clear cones
}


void mobileLeft20(){ //Mobile left 20
	motor[mClaw] = rollerPassive;
	mobile(127,-900);
	//driveMobile(127, 1500);
	drive(127, 1500);
	/*mobile(127,-50);
	dr4b(100,2200);
	motor[mClaw] = -127;
	wait1Msec(400);
	motor[mClaw] = 0;
	drive(75, 1500-lastDis);
	motor[mClaw] = 127;
	motor[mChainbar] = -127;
	dr4b(127,2060);
	motor[mLift] = -127;
	wait1Msec(400);
	motor[mClaw] = rollerPassive;
	motor[mChainbar] = 0;
	motor[mLift] = 0;
	/*dr4b(100,2300);
	motor[mChainbar] = 127;
	wait1Msec(500);
	motor[mChainbar] = 0;
	dr4b(100,2150);
	motor[mClaw] = -127;
	wait1Msec(400);
	drive(127, -1500);
	motor[mClaw] = 0;
	//PIDmove(127, lastDis);
	turnG(85, 230); //-45?
	//PIDturnG(70,-x);
	drive(85,-300);
	//PIDmove(85,-x);
	turnG(85, 700); //-90?
	//PIDturnG(85,-x);
	drive(127,-200);
	driveTime(127,775,2750);
	//PIDmove(127,x);
	mobile(127,-900);
	mobile(127, -100);
	drive(127, -500);*/
	//mobile out
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn towards center
	//forward/back
	//turn towards corner
	//forward
	//mobile out
	//back up
}

void mobileRight20(){ //mobile right 20
	motor[mClaw] = rollerPassive;
	mobile(127,-900);
	driveMobile(127, 1700);
	//PIDmoveMobile(127,x);
	mobile(127,-50);
	dr4b(127,2260);
	motor[mClaw] = -127;
	drive(127, (-lastDis + 150));
	motor[mClaw] = 0;
	//PIDmove(127, lastDis);
	turnG(85, -250); //-45?
	//PIDturnG(70,-x);
	drive(85,-450);
	//PIDmove(85,-x);
	turnG(85, -750); //-90?
	//PIDturnG(85,-x);
	drive(127,-200);
	driveTime(127,800, 3000);
	//PIDmove(127,x);
	mobile(127,-900);
	mobile(127, -100);
	drive(127, -500);
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn towards center
	//forward/back
	//turn towards corner
	//forward
	//mobile out
	//back up
}

void mobileLeft10(){
	motor[mClaw] = rollerPassive;
	mobile(127,-900);
	driveMobile(127, 1500);
	//PIDmoveMobile(127,x);
	mobile(127,-20);
	dr4b(127,2260);
	motor[mClaw] = -127;
	drive(127, (-lastDis + 150));
	motor[mClaw] = 0;
	turnG(60,1350); //135
	driveTime(75,100, 750);
	mobile(127,-900);
	drive(127,-1000);
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn around
	//dump mobile into 10 point
	//backup
}

void mobileRight10(){
	motor[mClaw] = rollerPassive;
	mobile(127,-900);
	driveMobile(127, 1500);
	//PIDmoveMobile(127,x);
	mobile(127,-20);
	dr4b(127,2260);
	motor[mClaw] = -127;
	drive(127, (-lastDis + 150));
	motor[mClaw] = 0;
	turnG(60,-1500); //-135
	driveTime(60,100,750);
	mobile(127,-900);
	drive(127,-1000);
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn around
	//dump mobile into 10 point
	//backup
}

void mobileLeft5(){

}

void mobileRight5(){

}

void trickStationLeft(){

}

void trickStationRight(){

}

void trickMobileLeft20(){

}

void trickMobileRight20(){

}

void trickMobileLeft5(){

}

void trickMobileRight5(){

}

void pragmaSkills(){ //Programming Skills
	motor[mClaw] = rollerPassive;
	mobile(127,-900);
	driveMobile(127, 1500);
	//PIDmoveMobile(127,x);
	mobile(127,-20);
	dr4b(127,2260);
	motor[mClaw] = -127;
	drive(127, (-lastDis + 150));
	motor[mClaw] = 0;
	turnG(85,1350); //135
	driveTime(75,150, 750);
	mobile(127,-900);
	drive(127,-200);
	turnG(85, 1000);
	dr4b(127, 3000);
	driveTime(127,-750, 1000);
	mobile(127, -50);
	mobile(127, -900);
	drive(127, 400);
	dr4b(127,2500);
	turnG(70, 130);
	driveMobile(100, 700);
	mobile(127, -50);
	drive(127,-lastDis);
	turnG(85,-700);
	drive(127, 600);
	turnG(85,-650);
	driveTime(127,1300, 5000);
	mobile(127,-900);
	mobile(127, -50);
	drive(127, -900);
	turnG(85, -450);
	driveTime(127, -1900, 5800);
	//refer to sheet
}

void autonTest(){
	PIDturnG(1, 450);
}

void autonSelecter(){
	switch(autonNumber){
	case 0: //none
		autonTest();
		break;
	case 1: //Stationary close (center)
		stationLeft();
		break;
	case 2: ////Stationary far (wings)
		stationRight();
		break;
	case 3: //Mobile Left 20
		mobileLeft20();
		break;
	case 4: //Mobile Right 20
		mobileRight20();
		break;
	case 5:
		mobileLeft10();
		break;
	case 6:
		mobileRight10();
		break;
	case 7:
		mobileLeft5();
		break;
	case 8:
		mobileRight5();
		break;
	case 9:
		//auton9();
		autonTest();
		break;
	case 10:
		trickStationRight();
		break;
	case 11:
		trickMobileLeft20();
		break;
	case 12:
		trickMobileRight20();
		break;
	case 13:
		trickMobileLeft5();
		break;
	case 14:
		trickMobileRight5();
		break;
	case 15: //Skills
		pragmaSkills();
		break;
	default:
		break;
	}
}
	//Stationary left - 1
	//Stationary right - 2
	//Mobile Left 20: 1 Cone, 4 Cone - 3
	//Mobile Right 20: 1 Cone, 4 Cone - 4
	//Mobile Left 10: 1 Cone, 4 Cone - 5
	//Mobile Right 10: 1 Cone, 4 Cone - 6
	//Mobile Left 5: 1 Cone, 4 Cone - 7
	//Mobile Right 5: 1 Cone, 4 Cone - 8
	//Trick Stationary left - 9
	//Trick Stationary right - 10
	//Trick 20 left- 11
	//Trick 20 right - 12
	//Trick 5 left - 13
	//Trick 5 right - 14
	//Programming skills - 15

void pre_auton(){
	bStopTasksBetweenModes = true;
}

task autonomous(){
	autonNumber = 0;
	reset(23);
	reset(4);
	autonRead();
	autonSelecter();
}

task usercontrol(){
	motor[port1] = 0;
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
	motor[port8] = 0;
	motor[port9] = 0;
	motor[port10] = 0;
	reset(0);
	bLCDBacklight = false;
	//reset motors

	while(true){
		Variables(); //configure variables
		Control();//set control
		lcd();
		//autoLoads(coneStack);
		if(vexRT[Btn7U] == 1 ||  vexRT[Btn7UXmtr2] == 1){
			SensorValue[gBase1] = 0;
			SensorValue[gMobile3] = 0;
			SensorValue[qLeftDrive11] = 0;
			SensorValue[qRightDrive12] = 0;
			//SensorValue[gLiftTilt] = 0;
		}
	}
}
