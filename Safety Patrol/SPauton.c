#pragma config(Sensor, in1,    gBase1,         sensorGyro)
#pragma config(Sensor, in2,    gLift2,         sensorGyro)
#pragma config(Sensor, in3,    gMobile3,       sensorGyro)
#pragma config(Sensor, in4,    lMobile,        sensorLineFollower)
#pragma config(Sensor, in5,    lLeft,          sensorLineFollower)
#pragma config(Sensor, in6,    lMiddle,        sensorLineFollower)
#pragma config(Sensor, in7,    lRight,         sensorLineFollower)
#pragma config(Sensor, in8,    pClaw,          sensorPotentiometer)
#pragma config(Sensor, dgtl1,  qLeftDrive7,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  qRightDrive8,   sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  jAuton8,        sensorTouch)
#pragma config(Sensor, dgtl10, jAuton4,        sensorTouch)
#pragma config(Sensor, dgtl11, jAuton2,        sensorTouch)
#pragma config(Sensor, dgtl12, jAuton1,        sensorTouch)
#pragma config(Motor,  port1,           mLeftTop,      tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           mLeftBottom,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           mLiftLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           mMobileLeft,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mClaw,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           mChainbar,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           mMobileRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           mLiftRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           mRightBottom,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          mRightTop,     tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "SPuser.c"

int moveDir;
int liftDir;
int turnDir;
int autonNumber;
bool mobileOut;
int timer;

int oldQuadValue;
int disDiff;
int CMV;
int NMV;
int motDiff;
void mobile(int pwr, int angle){
	timer = nSysTime;
	if(mobileOut == false){
		while(SensorValue[gMobile2] > -angle && nSysTime - timer <= 1000){
			motor[mMobileLeft] = -pwr;
			motor[mMobileRight] = -pwr;
		}
		mobileOut = true;
	}
	else if(mobileOut == true){
		while(SensorValue[gMobile2] < angle && SensorValue[tMobileUp] == 0 && nSysTime - timer <= 1000){
			motor[mMobileLeft] = pwr;
			motor[mMobileRight] = pwr;
		}
		mobileOut = false;
	}
	motor[mMobileLeft] = 0;
	motor[mMobileRight] = 0;
	reset(2);
}

void turnG(int angle){
	if(angle < 0){
		turnDir = -1;
	}
	else{
		turnDir = 1;
	}
	while((angle < 0 && SensorValue[gBase1] > angle) || (angle > 0 && SensorValue[gBase1] < angle)){
		lDrive(127*turnDir);
		rDrive(127*-turnDir);
	}
	rDrive(0);
	lDrive(0);
	reset(11);
}

void turnQ(int dis){
	if(dis > 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while((dis < 0 && SensorValue[qLeftDrive5] >= dis && qRightCorrected >= dis) ||
		(dis > 0 && SensorValue[qLeftDrive5] <= dis && qRightCorrected <= dis)){
		lDrive(127*moveDir);
		rDrive(127*-moveDir);
	}
	lDrive(0);
	rDrive(0);
	reset(11);
}
void dr4b(int angle, int pwr){
	if(angle < 0){
		liftDir = -1;
	}
	else{
		liftDir = 1;
	}
	while((angle > 0 && SensorValue[pLift] < angle) || (angle < 0 && SensorValue[pLift] > angle)){
		motor[mLiftLeft] = pwr*liftDir;
		motor[mLiftRight] = pwr*liftDir;
	}
	motor[mLiftLeft] = 0;
	motor[mLiftRight] = 0;
}

void drive(int dis, int Lpwr, int Rpwr){
	if(dis > 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while(((dis < 0 && SensorValue[qLeftDrive5] >= dis && qRightCorrected <= dis) ||
		(dis > 0 && SensorValue[qLeftDrive5] <= dis && qRightCorrected >= dis))){
		lDrive(Lpwr*moveDir);
		rDrive(Rpwr*moveDir);
	}
	lDrive(0);
	rDrive(0);
	reset(11);
}

void driveMobile(int dis, int Lpwr, int Rpwr){
	if(dis > 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while(((dis < 0 && SensorValue[qLeftDrive5] >= dis && qRightCorrected <= dis) ||
		(dis > 0 && SensorValue[qLeftDrive5] <= dis && qRightCorrected >= dis)) &&
	(SensorValue[lMobile] >= 2000)){
		lDrive(Lpwr*moveDir);
		rDrive(Rpwr*moveDir);
	}
	lDrive(0);
	rDrive(0);
	reset(11);
}

void PIDmove(int dis, int pwr){
	if(dis > 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	oldQuadValue = SensorValue[qLeftDrive5];
	CMV = pwr*moveDir;
	while(((dis < 0 && SensorValue[qLeftDrive5] >= dis && qRightCorrected <= dis) ||
		(dis > 0 && SensorValue[qLeftDrive5] <= dis && qRightCorrected >= dis))){
		disDiff = SensorValue[qLeftDrive5] + oldQuadValue;
		motDiff = (pwr - 0)/dis*disDiff;
		NMV = CMV - motDiff;
		lDrive(NMV);
		rDrive(NMV);
		CMV = NMV;
		oldQuadValue = SensorValue[qLeftDrive5];
	}
}

void PIDmoveMobile(int dis,int pwr){
	if(dis > 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	oldQuadValue = SensorValue[qLeftDrive5];
	CMV = pwr*moveDir;
	while(((dis < 0 && SensorValue[qLeftDrive5] >= dis && qRightCorrected <= dis) ||
		(dis > 0 && SensorValue[qLeftDrive5] <= dis && qRightCorrected >= dis)) &&
	(SensorValue[lMobile] >= 2000)){
		disDiff = SensorValue[qLeftDrive5] + oldQuadValue;
		motDiff = (pwr - 0)/dis*disDiff;
		NMV = CMV - motDiff;
		lDrive(NMV);
		rDrive(NMV);
		CMV = NMV;
		oldQuadValue = SensorValue[qLeftDrive5];
	}
}

void PIDturnG(int angle, int pwr){
	if(angle < 0){
		turnDir = -1;
	}
	else{
		turnDir = 1;
	}
	while((angle < 0 && SensorValue[gBase1] > angle) || (angle > 0 && SensorValue[gBase1] < angle)){
		disDiff = SensorValue[qLeftDrive5] + oldQuadValue;
		motDiff = (pwr - 0)/angle*disDiff;
		NMV = CMV - motDiff;
		lDrive(NMV*turnDir);
		rDrive(NMV*-turnDir);
		CMV = NMV;
		oldQuadValue = SensorValue[qLeftDrive5];
	}
	rDrive(0);
	lDrive(0);
	reset(11);
}

void PIDturnQ(int dis, int pwr){
	if(dis > 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while((dis < 0 && SensorValue[qLeftDrive5] >= dis && qRightCorrected >= dis) ||
		(dis > 0 && SensorValue[qLeftDrive5] <= dis && qRightCorrected <= dis)){
		disDiff = SensorValue[qLeftDrive5] + oldQuadValue;
		motDiff = (pwr - 0)/dis*disDiff;
		NMV = CMV - motDiff;
		lDrive(NMV*moveDir);
		rDrive(NMV*-moveDir);
		CMV = NMV;
		oldQuadValue = SensorValue[qLeftDrive5];
	}
	lDrive(0);
	rDrive(0);
	reset(11);
}

void autonSelecter(){
	if(SensorValue[jAuton1] == true){
		autonNumber += 1;
	}
	if(SensorValue[jAuton2] == true){
		autonNumber += 2;
	}
	if(SensorValue[jAuton4] == true){
		autonNumber += 4;
	}
	if(SensorValue[jAuton8] == true){
		autonNumber += 8;
	}
	switch(autonNumber){
	case 0: //none
		break;
	case 1:
		Auton1();
		break;
	case 2:
		Auton2();
		break;
	case 3:
		Auton3();
	default:
		break;
	}
}

void pre_auton(){
  bStopTasksBetweenModes = true;
}

task autonomous(){
	autonNumber = 0;
	reset(14);
	mobileOut = false;
	autonSelecter();
}
