#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    gBase1,         sensorGyro)
#pragma config(Sensor, in2,    pLift2,         sensorPotentiometer)
#pragma config(Sensor, in3,    gMobile3,       sensorGyro)
#pragma config(Sensor, in5,    lMobile,        sensorLineFollower)
#pragma config(Sensor, in7,    p4Bar,          sensorPotentiometer)
#pragma config(Sensor, dgtl1,  jAuton1,        sensorTouch)
#pragma config(Sensor, dgtl2,  jAuton2,        sensorTouch)
#pragma config(Sensor, dgtl3,  jAuton4,        sensorTouch)
#pragma config(Sensor, dgtl4,  jAuton8,        sensorTouch)
#pragma config(Sensor, dgtl5,  jAuton16,       sensorTouch)
#pragma config(Sensor, dgtl9,  qRightDrive12,  sensorQuadEncoder)
#pragma config(Sensor, dgtl11, qLeftDrive11,   sensorQuadEncoder)
#pragma config(Motor,  port1,           mClaw,         tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           mLift,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           mRightTop,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           mRightBack,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           mRightFront,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           mLeftFront,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           mLeftBack,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           mLeftTop,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           mMobile,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          mChainbar,     tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"



#include "SPuser.c"



int x;
int lastDis;
int moveDir;
int liftDir;
int turnDir;
int mobileDir;
int chainbarDir;
int timer;

int oldQuadValue;
int disDiff;
float CMV;
float NMV;
float motDiff;

void mobile(int pwr, int angle){ //0 in, -900 out,
	while(SensorValue[pLift2] < liftMobileAngle){
		motor[mLift] = 127;
	}
	motor[mLift] = 0;
	timer = nSysTime;
	if(angle < SensorValue[gMobile3]){
		mobileDir = 1;
	}
	else{
		mobileDir = -1;
	}
	while(((mobileDir == 1 && SensorValue[gMobile3] >= angle) || (mobileDir == -1 && SensorValue[gMobile3] <= angle)) && nSysTime - timer <= 2500){
		motor[mMobile] = pwr*mobileDir;
	}
	motor[mMobile] = 0;
}

void dr4b(int pwr, int angle){
	if(angle > SensorValue[pLift2]){
		liftDir = 1;
	}
	else{
		liftDir = -1;
	}
	while(((liftDir == 1 && SensorValue[pLift2] <= angle) || (liftDir == -1 && SensorValue[pLift2] >= angle)) && !(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 1)){
		motor[mLift] = pwr*liftDir;
	}
	motor[mLift] = 0;
}

void chainbar(int angle){
	if(angle > SensorValue[p4Bar]){
		chainbarDir = 1;
	}
	else{
		chainbarDir = -1;
	}
	while((chainbarDir == 1 && SensorValue[p4Bar] <= angle) || (chainbarDir == -1 && SensorValue[p4Bar] >= angle)){
		motor[mChainbar] = 127*chainbarDir;
	}
	motor[mChainbar] = 0;
}

void turnG(int pwr,int angle){
	if(angle < 0){
		turnDir = -1;
	}
	else{
		turnDir = 1;
	}
	while((angle < 0 && SensorValue[gBase1] > angle) || (angle > 0 && SensorValue[gBase1] < angle)){
		lDrive(pwr*-turnDir);
		rDrive(pwr*turnDir);
	}
	rDrive(0);
	lDrive(0);
	reset(0);
}

void turnQ(int dis, int pwr){
	if(dis > 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while((dis < 0 && SensorValue[qLeftDrive11] >= dis && SensorValue[qRightDrive12] <= -dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] <= dis && SensorValue[qRightDrive12] >= -dis)){
		lDrive(pwr*moveDir);
		rDrive(pwr*-moveDir);
	}
	lDrive(0);
	rDrive(0);
	reset(0);
}

void drive(int pwr, int dis){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while((dis < 0 && SensorValue[qLeftDrive11] >= dis && SensorValue[qRightDrive12] <= -dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] <= dis && SensorValue[qRightDrive12] >= -dis)){
		lDrive(pwr*moveDir);
		rDrive(pwr*moveDir);
	}
	lDrive(0);
	rDrive(0);
	lastDis = SensorValue[qLeftDrive11];
	reset(0);
}

void driveTime(int pwr, int dis, int time){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	timer = nSysTime;
	while(((dis < 0 && SensorValue[qLeftDrive11] >= dis && SensorValue[qRightDrive12] <= -dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] <= dis && SensorValue[qRightDrive12] >= -dis)) && (nSysTime - timer <= time)){
		lDrive(pwr*moveDir);
		rDrive(pwr*moveDir);
	}
	lDrive(0);
	rDrive(0);
	lastDis = SensorValue[qLeftDrive11];
	reset(0);
}

void driveMobile(int pwr, int dis){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while(((dis < 0 && SensorValue[qLeftDrive11] >= dis && SensorValue[qRightDrive12] <= -dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] <= dis && SensorValue[qRightDrive12] >= -dis)) && (SensorValue[lMobile] >= 2000)){
		lDrive(pwr*moveDir);
		rDrive(pwr*moveDir);
	}
	lDrive(0);
	rDrive(0);
	lastDis = SensorValue[qLeftDrive11];
	reset(0);

}

void PIDmove(int pwr, int dis){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	CMV = pwr*moveDir;
	NMV = CMV;
	timer = nSysTime;
	while((dis < 0 && SensorValue[qLeftDrive11] <= -dis && SensorValue[qRightDrive12] >= dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] >= -dis && SensorValue[qRightDrive12] <= dis)){
		if(nSysTime - timer >= 100 && SensorValue[qLeftDrive11] >= dis*.75){
			disDiff = -(SensorValue[qLeftDrive11] - oldQuadValue);
			motDiff = (pwr*1.0-30)/(dis*.25)*disDiff;
			NMV = CMV - motDiff;
			oldQuadValue = SensorValue[qLeftDrive11];
			CMV = NMV;
			timer = nSysTime;
		}
		lDrive(NMV);
		rDrive(NMV);
	}
	reset(0);
	lDrive(0);
	rDrive(0);
	CMV = 0;
	NMV = 0;
	motDiff = 0;
	oldQuadValue = 0;
	motDiff = 0;
	lastDis = SensorValue[qLeftDrive11];
}

void PIDmoveMobile(int pwr,int dis){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	oldQuadValue = SensorValue[qLeftDrive11];
	CMV = pwr*moveDir;
	timer = nSysTime;
	while(((dis < 0 && SensorValue[qLeftDrive11] <= -dis && SensorValue[qRightDrive12] >= dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] >= -dis && SensorValue[qRightDrive12] <= dis)) && (SensorValue[lMobile] >= 2000)){
		if(nSysTime - timer >= 100 && SensorValue[qLeftDrive11] >= dis*.75){
			disDiff = -(SensorValue[qLeftDrive11] - oldQuadValue);
			motDiff = (pwr*1.0-30)/dis*disDiff;
			NMV = CMV - motDiff;
			oldQuadValue = SensorValue[qLeftDrive11];
			CMV = NMV;
			timer = nSysTime;
		}
		lDrive(NMV);
		rDrive(NMV);
	}
	reset(0);
	lDrive(0);
	rDrive(0);
	CMV = 0;
	NMV = 0;
	motDiff = 0;
	oldQuadValue = 0;
	motDiff = 0;
	lastDis = SensorValue[qLeftDrive11];
}

float gkP = 0.35;
float gkI = 0.08;
float gkD = 0.007;
float gPower = 30;
float lastPower[10] = {0,0,0,0,0,0,0,0,0,0};
int lastAngle[3] = {0,0,0};
//gyro-based PID turning
void PIDturnG(float pwr, int angle){
	int gIntegral = 0;
	int gDerivative = 0;
	int prevError = angle - SensorValue[gBase1];
	while(!(abs(angle - lastAngle[2]) <= 5 && abs(angle - SensorValue[gBase1]) <= 5) && lastPower[9] != gPower){
		int error = angle - SensorValue[gBase1];
		if(error == 0 || sgn(error*angle) == -1){
			gIntegral = 0;
		}
		if(gIntegral > 75000){
			gIntegral = 0;
		}
		gDerivative = error - prevError;
		prevError = error;
		gPower =  pwr * (gkP * error + gkI * gIntegral +  gkD * gDerivative);
		//if(abs(gPower) < 33 && abs(gPower) > 0) gPower = sgn(gPower)*33;
		lDrive(-PowerCap((int)gPower));
		rDrive(PowerCap((int)gPower));
		for(int p = 8; p >= 0; p--){
			lastPower[p+1] = lastPower[p];
		}
		for(int a = 1; a >= 0; a--){
			lastAngle[a+1] = lastAngle[a];
		}
		lastPower[0] = gPower;
		lastAngle[0] = SensorValue[gBase1];
		wait1Msec(20);
	}
	lDrive(0);
	rDrive(0);
	reset(0);
	gPower = 30;
	//https://www.vexforum.com/index.php/6465-a-pid-controller-in-robotc/0
}

int loadAngle = 215;
int potDown = 2600;
int potUp = 4095;
int stackAngs[14] = {130, 165, 200, 235, 285, 335, 385, 435, 475, 510, 565, 655, 700, 700};

void autoLoads(int num) {
	while(vexRT[Btn8U] == 1){
		waitUntil(vexRT[Btn8U] != 1);
		coneStack++;
		num++;
		if(SensorValue[pLift2] < loadAngle){
			dr4b(127, loadAngle);
		}
		while(SensorValue[p4Bar] >= potDown  && !(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 1)){
			motor[mChainbar] = -127;
		}
		motor[mChainbar] = 0;
		motor[mClaw] = 80;
		dr4b(100, loadAngle);
		motor[mChainbar] = -90;
		wait1Msec(100);
		motor[mChainbar] = 0;
		motor[mClaw] = 20;
		dr4b(127, stackAngs[num]);
		while(SensorValue[p4Bar] < potUp  && !(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 1)){
			motor[mChainbar] = 127;
		}
		motor[mChainbar] = 0;
		wait1Msec(100);
		motor[mLift] = -127;
		motor[mClaw] = -127;
		wait1Msec(200);
		motor[mLift] = 0;
		wait1Msec(200);
		motor[mClaw] = 20;
	}
	while(vexRT[Btn8D] == 1){
		waitUntil(vexRT[Btn8D] != 1);
		coneStack--;
	}
	while(vexRT[Btn8R] == 1){
		waitUntil(vexRT[Btn8R] != 1);
		if(SensorValue[pLift2] < loadAngle){
			dr4b(100, loadAngle);
		}
		while(SensorValue[p4Bar] >= potDown  && !(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 1)){
			motor[mChainbar] = -127;
		}
		motor[mChainbar] = 0;
		motor[mClaw] = 80;
		dr4b(127, loadAngle);
		motor[mChainbar] = -40;
		wait1Msec(100);
		motor[mChainbar] = 0;
		motor[mClaw] = 20;
		dr4b(127,stackAngs[num]);
		while(SensorValue[p4Bar] < potUp && !(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 1)){
			motor[mChainbar] = 127;
		}
		motor[mChainbar] = 0;
		wait1Msec(100);
		motor[mClaw] = -127;
		wait1Msec(400);
		motor[mClaw] = 20;
	}
}


//2260 = lift all Down
//2500 = Mobile Goal Clear
//3020 = Stat. clear
//2870 = On stat.

void stationLeft(){ //long stationary left
	motor[mClaw] = rollerPassive;
	motor[mChainbar] = -127;
	wait1Msec(500);
	motor[mChainbar] = 0;
	dr4b(127,3300);
	drive(90,400);
	//PIDmove(60,600);
	dr4b(127,2800);
	motor[mClaw] = -127;
	wait1Msec(100);
	dr4b(127,3000);
	motor[mClaw] = 0;
	drive(85,-50);
	dr4b(127,2500);
	turnG(100,-925);
	driveTime(127,-2200,4000);
	//lift up
	//drive forward
	//drop lift
	//rollers reverse
	//move lift up
	//stop rollers
	//back up
	//turn
	//back up to clear cones */
}

void stationRight(){ //long stationary right
	motor[mClaw] = rollerPassive;
	motor[mChainbar] = -127;
	wait1Msec(500);
	motor[mChainbar] = 0;
	dr4b(127,3300);
	drive(85,325);
	//PIDmove(60,600);
	dr4b(127,2800);
	motor[mClaw] = -127;
	wait1Msec(100);
	dr4b(127,3000);
	motor[mClaw] = 0;
	drive(85,-50);
	dr4b(127,2500);
	turnG(100,830);
	driveTime(127,-2200, 4000);
	//lift up
	//drive forward
	//drop lift
	//rollers reverse
	//move lift up
	//stop rollers
	//back up
	//turn
	//back up to clear cones
}

void threeCone(){
	motor[mClaw] = rollerPassive;
	mobile(127,-900);
	driveMobile(127, 1500);
	mobile(127,-50);
	dr4b(100,2200);
	motor[mClaw] = -127;
	wait1Msec(400);
	motor[mClaw] = 0;
	drive(90, 195);
	motor[mClaw] = 127;
	motor[mChainbar] = -127;
	dr4b(127,2150);
	motor[mLift] = -127;
	wait1Msec(400);
	lDrive(-30);
	rDrive(-30);
	wait1Msec(300);
	motor[mClaw] = 50;
	motor[mChainbar] = 0;
	motor[mLift] = 0;
	lDrive(0);
	rDrive(0);
	dr4b(100,2300);
	motor[mChainbar] = 127;
	wait1Msec(500);
	motor[mChainbar] = 0;
	dr4b(100,2275);
	wait1Msec(200);
	motor[mClaw] = -127;
	wait1Msec(400);
}

void mobile20Left3(){ //Mobile left 20
	threeCone();
	drive(127, -1300);
	motor[mClaw] = 0;
	PIDturnG(0.5,450);
	drive(85,-450);
	PIDturnG(0.5,900);
	drive(127,-200);
	driveTime(127,900,2750);
	mobile(127,-900);
	mobile(127, -100);
	drive(127, -500);
	//mobile out
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn towards center
	//forward/back
	//turn towards corner
	//forward
	//mobile out
	//back up
}

void mobile20Right3(){ //mobile right 20
	threeCone();
	drive(127, -1200);
	motor[mClaw] = 0;
	PIDturnG(0.5,1400);
	drive(85,450);
	PIDturnG(0.5,900);
	drive(127,-100);
	driveTime(127,900, 2750);
	mobile(127,-900);
	mobile(127, -100);
	drive(127, -500);
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn towards center
	//forward/back
	//turn towards corner
	//forward
	//mobile out
	//back up
}

void mobile10Left3(){
	threeCone();
	drive(127, -1300);
	motor[mClaw] = 0;
	PIDturnG(0.5, 1500);
	driveTime(75,100, 750);
	mobile(127,-900);
	drive(127,-2250);
	PIDturnG(0.5, 800);
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn around
	//dump mobile into 10 point
	//backup
}

void mobile10Right3(){
	threeCone();
	drive(127, -1000);
	motor[mClaw] = 0;
	PIDturnG(0.5, 2250);
	driveTime(75,100, 750);
	mobile(127,-900);
	drive(127,-500);
	PIDturnG(0.5, -200);
	drive(127,-1000);
	PIDturnG(0.5, -1000);
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn around
	//dump mobile into 10 point
	//backup
}

void mobile5Left3(){
	threeCone();
	drive(127, -1100);
	motor[mClaw] = 0;
	PIDturnG(0.5, 1350);
	drive(90, -150);
	dr4b(127,2500);
	mobile(127,-900);
	drive(127,-1500);
	PIDturnG(0.5, 900);
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn around
	//dump mobile into 10 point
	//backup
}

void mobile5Right3(){
	threeCone();
	drive(127, -1100);
	motor[mClaw] = 0;
	PIDturnG(0.5, 2250);
	drive(90, -150);
	mobile(127,-900);
	drive(127,-1500);
	PIDturnG(0.5, -900);
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn around
	//dump mobile into 10 point
	//backup
}

void twoCone(){
	motor[mClaw] = 127;
	mobile(127,-900);
	motor[mClaw] = rollerPassive;
	driveMobile(127, 1500);
	mobile(127,-50);
	dr4b(100,2300);
	motor[mClaw] = -127;
	wait1Msec(400);
	motor[mClaw] = 0;
	drive(90, 195);
	motor[mClaw] = 127;
	motor[mChainbar] = -127;
	dr4b(127,2300);
	motor[mLift] = -127;
	wait1Msec(400);
	lDrive(-30);
	rDrive(-30);
	wait1Msec(300);
	motor[mClaw] = 50;
	motor[mChainbar] = 0;
	motor[mLift] = 0;
	lDrive(0);
	rDrive(0);
	dr4b(100,2300);
	motor[mChainbar] = 127;
	wait1Msec(750);
	motor[mChainbar] = 0;
	dr4b(100,2275);
	wait1Msec(200);
	motor[mClaw] = -127;
	wait1Msec(400);
}

void mobile20Left2(){ //Mobile left 20
	twoCone();
	drive(127, -1300);
	motor[mClaw] = 0;
	PIDturnG(0.5,450);
	drive(85,-450);
	PIDturnG(0.5,900);
	drive(127,-200);
	driveTime(127,900,2750);
	mobile(127,-900);
	mobile(127, -100);
	drive(127, -500);
	//mobile out
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn towards center
	//forward/back
	//turn towards corner
	//forward
	//mobile out
	//back up
}

void mobile20Right2(){ //mobile right 20
	twoCone();
	drive(127, -1200);
	motor[mClaw] = 0;
	PIDturnG(0.5,1400);
	drive(85,450);
	PIDturnG(0.5,900);
	drive(127,-100);
	driveTime(127,900, 2750);
	mobile(127,-900);
	mobile(127, -100);
	drive(127, -500);
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn towards center
	//forward/back
	//turn towards corner
	//forward
	//mobile out
	//back up
}

void mobile10Left2(){
	twoCone();
	drive(127, -1300);
	motor[mClaw] = 0;
	PIDturnG(0.5, 1500);
	driveTime(75,100, 750);
	mobile(127,-900);
	drive(127,-2250);
	PIDturnG(0.5, 800);
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn around
	//dump mobile into 10 point
	//backup
}

void mobile10Right2(){
	twoCone();
	drive(127, -1000);
	motor[mClaw] = 0;
	PIDturnG(0.5, 2250);
	driveTime(75,100, 750);
	mobile(127,-900);
	drive(127,-500);
	PIDturnG(0.5, -200);
	drive(127,-1000);
	PIDturnG(0.5, -1000);
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn around
	//dump mobile into 10 point
	//backup
}

void mobile5Left2(){
	twoCone();
	drive(127, -1100);
	motor[mClaw] = 0;
	PIDturnG(0.5, 1350);
	drive(90, -150);
	dr4b(127,2500);
	mobile(127,-900);
	drive(127,-1500);
	PIDturnG(0.5, 900);
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn around
	//dump mobile into 10 point
	//backup
}

void mobile5Right2(){
	twoCone();
	drive(127, -1100);
	motor[mClaw] = 0;
	PIDturnG(0.5, 2250);
	drive(90, -150);
	mobile(127,-900);
	drive(127,-1500);
	PIDturnG(0.5, -900);
	//drive forward
	//intake mobile
	//lift down
	//eject cone
	//back up
	//turn around
	//dump mobile into 10 point
	//backup
}

void trickStationLeft(){
	PIDturnG(0.5, 900);
	stationLeft();
}

void trickStationRight(){
	PIDturnG(0.5, -900);
	stationRight();
}

void trickMobile20Left3(){
	PIDturnG(0.5, 900);
	mobile20Left3();
}

void trickMobile20Right3(){
	PIDturnG(0.5, -900);
	mobile20Right3();
}

void trickMobile10Left3(){
	PIDturnG(0.5, 900);
	mobile10Left3();
}

void trickMobile10Right3(){
	PIDturnG(0.5, -900);
	mobile10Right3();
}

void trickMobile5Left3(){
	PIDturnG(0.5, 900);
	mobile5Left3();
}

void trickMobile5Right3(){
	PIDturnG(0.5, -900);
	mobile5Right3();
}

void trickMobile20Left2(){
	PIDturnG(0.5, 900);
	mobile20Left2();
}

void trickMobile20Right2(){
	PIDturnG(0.5, -900);
	mobile20Right2();
}

void trickMobile10Left2(){
	PIDturnG(0.5, 900);
	mobile10Left2();
}

void trickMobile10Right2(){
	PIDturnG(0.5, -900);
	mobile10Right2();
}

void trickMobile5Left2(){
	PIDturnG(0.5, 900);
	mobile5Left2();
}

void trickMobile5Right2(){
	PIDturnG(0.5, 900);
	mobile5Right2();
}

void pragmaSkills(){ //Programming Skills
	motor[mClaw] = rollerPassive;
	mobile(127,-900);
	driveMobile(127, 1500);
	mobile(127,-50);
	dr4b(127,2200);
	motor[mClaw] = -127;
	wait1Msec(400);
	motor[mClaw] = 0;
	drive(127, -1200);
	motor[mClaw] = 0;
	PIDturnG(0.5,1350); //135
	driveTime(75,150, 750);
	mobile(127,-900);
	drive(127,-200);
	mobile(127, -100);
	PIDturnG(0.5, 1200);
	dr4b(127, 3000);
	driveTime(127,-750, 1000);
	mobile(127, -900);
	drive(127, 200);
	PIDturnG(0.5, 325);
	dr4b(127,2200);
	driveMobile(100, 1400);
	mobile(127, -50);
	drive(127,-350);
	PIDturnG(0.5, -800);
	drive(127, 350);
	PIDturnG(0.5, -900);
	driveTime(127, 1000, 2500);
	mobile(127,-900);
	mobile(127, -50);
	drive(127, -500);
	PIDturnG(0.5, -900);
	drive(127, -300);
	PIDturnG(0.5, -900);
	mobile(127, -900);
	driveMobile(127,800);
	mobile(127,-200);
	PIDturnG(0.7, -1900);
	driveTime(85, 1000, 2500);
	mobile(127, -900);
	drive(127, -200);
	mobile(127,-200);
	PIDturnG(0.7, -1850);
	mobile(127, -900);
	driveMobile(127,2100);
	mobile(127, -200);
	driveTime(85, 1000, 1500);
	mobile(127, -900);
	drive(100, -200);
	PIDturnG(1.0, 45);
	driveTime(127, -2200, 3200);
	//refer to sheet
}

void autonTest(){
}

void autonSelecter(){
	switch(autonNumber){
	case 0: //test
		autonTest();
		break;
	case 2: //mogo 20 left 3
		mobile20Left3();
		break;
	case 3: //trick 20 left 3
		trickMobile20Left3();
		break;
	case 4: //mogo 20 right 3
		mobile20Right3();
		break;
	case 5://trick 20 right 3
		trickMobile20Right3();
		break;
	case 6://mogo 10 left 3
		mobile10Left3();
		break;
	case 7://trick 10 left 3
		trickMobile10Left3();
		break;
	case 8://mogo 10 right 3
		mobile10Right3();
		break;
	case 9://trick 10 right 3
		trickMobile10Right3();
		break;
	case 10://mogo 5 left 3
		mobile5Left3();
		break;
	case 11://trick 5 left 3
		trickMobile5Left3();
		break;
	case 12://mogo 5 right 3
		mobile5Right3();
		break;
	case 13://trick 5 right 3
		trickMobile5Right3();
		break;
	case 14://stationary left
		stationLeft();
		break;
	case 15: //trick stationary left
		trickStationLeft();
		break;
	case 16: //stationary right
		stationRight();
		break;
	case 17: //trick stationary right
		trickStationRight();
		break;
	case 18: //mogo 20 left 2
		mobile20Left2();
		break;
	case 19: //trick 20 left 2
		trickMobile20Left2();
		break;
	case 20: //mogo 20 right 2
		mobile20Right2();
		break;
	case 21: //trick 20 right 2
		trickMobile20Right2();
		break;
	case 22: //mogo 10 left 2
		mobile10Left2();
		break;
	case 23: //trick 10 left 2
		trickMobile10Left2();
		break;
	case 24: //mogo 10 right 2
		mobile10Right2();
		break;
	case 25: //trick 10 right 2
		trickMobile10Right2();
		break;
	case 26: //mogo 5 left 2
		mobile5Left2();
		break;
	case 27: //trick 5 left 2
		trickMobile5Left2();
		break;
	case 28: //mogo 5 right 2
		mobile5Right2();
		break;
	case 29: //trick 5 right 2
		trickMobile5Right2();
		break;
	case 31: //pragma skills
		pragmaSkills();
		break;
	default:
		break;
	}
}

void pre_auton(){
	bStopTasksBetweenModes = true;
}

task autonomous(){
	autonNumber = 0;
	reset(23);
	reset(4);
	autonRead();
	autonSelecter();
}

task usercontrol(){
	motor[port1] = 0;
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
	motor[port8] = 0;
	motor[port9] = 0;
	motor[port10] = 0;
	reset(0);
	bLCDBacklight = false;
	//reset motors

	while(true){
		Variables(); //configure variables
		Control();//set control
		lcd();
		if(vexRT[Btn7U] == 1 ||  vexRT[Btn7UXmtr2] == 1){
			SensorValue[gBase1] = 0;
			SensorValue[gMobile3] = 0;
			SensorValue[qLeftDrive11] = 0;
			SensorValue[qRightDrive12] = 0;
		}
	}
}
