#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    gBase1,         sensorGyro)
#pragma config(Sensor, in2,    pLift2,         sensorPotentiometer)
#pragma config(Sensor, in3,    gMobile3,       sensorGyro)
#pragma config(Sensor, in4,    lMobile,        sensorLineFollower)
#pragma config(Sensor, in7,    p4Bar,          sensorPotentiometer)
#pragma config(Sensor, in8,    PowerExpander,  sensorAnalog)
#pragma config(Sensor, dgtl1,  jAuton1,        sensorTouch)
#pragma config(Sensor, dgtl2,  jAuton2,        sensorTouch)
#pragma config(Sensor, dgtl3,  jAuton4,        sensorTouch)
#pragma config(Sensor, dgtl4,  jAuton8,        sensorTouch)
#pragma config(Sensor, dgtl5,  jAuton16,       sensorTouch)
#pragma config(Sensor, dgtl6,  jAuton32,       sensorTouch)
#pragma config(Sensor, dgtl9,  qRightDrive12,  sensorQuadEncoder)
#pragma config(Sensor, dgtl11, qLeftDrive11,   sensorQuadEncoder)
#pragma config(Motor,  port1,           mRollers,      tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           mLift,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           mRightBack,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           mRightFront,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           mRightMiddle,  tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           mLeftFront,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           mLeftMiddle,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           mLeftBack,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           mMobile,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          m4Bar,         tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "WorldsUser.c"


int x;
int lastDis, moveDir, liftDir;
int timer;
bool coneDone = false;
bool mogoDone = false;
bool fourBarDone = false;

task coneOut(){
	coneDone = false;
	motor[mLift] = -127;
	wait1Msec(150);
	motor[mLift] = 0;
	motor[mRollers] = -127;
	wait1Msec(300);
	motor[mRollers] = 0;
	coneDone = true;
}

task mogoUp(){
	mogoDone = false;
	while(SensorValue[pLift2] > liftMobileAngle){
		motor[mLift] = 100;
	}
	motor[mLift] = 0;

	motor[mMobile] = -127;
	waitUntil(SensorValue[gMobile3] <= 50);
	motor[mMobile] = 0;
	mogoDone = true;
}

task mogoDown(){
	mogoDone = false;
	while(SensorValue[pLift2] > liftMobileAngle){
		motor[mLift] = 100;
	}
	motor[mLift] = 0;

	motor[mMobile] = 127;
	waitUntil(SensorValue[gMobile3] >= 900);
	motor[mMobile] = 0;
	mogoDone = true;
}

task fourBarDown(){
	fourBarDone = false;
	motor[m4Bar] = -127;
	waitUntil(SensorValue[p4Bar] >= 1400);
	motor[m4Bar] = 0;
	fourBarDone = true;
}

task fourBarUp(){
	fourBarDone = false;
	motor[m4Bar] = 127;
	waitUntil(SensorValue[p4Bar] <= 2700);
	motor[m4Bar] = 0;
	fourBarDone = true;
}

void dr4b(int pwr, int angle){
	if(angle < SensorValue[pLift2]){
		liftDir = 1;
	}
	else{
		liftDir = -1;
	}
	timer = nSysTime;
	while(((liftDir == 1 && SensorValue[pLift2] >= angle) || (liftDir == -1 && SensorValue[pLift2] <= angle)) && !(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 1) && nSysTime - timer <= 1230){
		motor[mLift] = pwr*liftDir;
	}
	motor[mLift] = 0;
}

void drive(int pwr, int dis){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while((dis < 0 && SensorValue[qLeftDrive11] >= dis && SensorValue[qRightDrive12] <= -dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] <= dis && SensorValue[qRightDrive12] >= -dis)){
		lDrive(pwr*moveDir);
		rDrive(pwr*moveDir);
	}
	lDrive(0);
	rDrive(0);
	lastDis = SensorValue[qLeftDrive11];
	reset(0);
}

void driveTime(int pwr, int dis, int time){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	timer = nSysTime;
	while(((dis < 0 && SensorValue[qLeftDrive11] >= dis && SensorValue[qRightDrive12] <= -dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] <= dis && SensorValue[qRightDrive12] >= -dis)) && (nSysTime - timer <= time)){
		lDrive(pwr*moveDir);
		rDrive(pwr*moveDir);
	}
	lDrive(0);
	rDrive(0);
	lastDis = SensorValue[qLeftDrive11];
	reset(0);
}

void driveMobile(int pwr, int dis){
	if(dis < 0){
		moveDir = -1;
	}
	else{
		moveDir = 1;
	}
	while(((dis < 0 && SensorValue[qLeftDrive11] >= dis && SensorValue[qRightDrive12] <= -dis) ||
		(dis > 0 && SensorValue[qLeftDrive11] <= dis && SensorValue[qRightDrive12] >= -dis)) && (SensorValue[lMobile] >= 2000)){
		lDrive(pwr*moveDir);
		rDrive(pwr*moveDir);
	}
	lDrive(0);
	rDrive(0);
	lastDis = SensorValue[qLeftDrive11];
	reset(0);
}

float gkP = 0.37, gkI = 0.1, gkD = 0.007, gPower = 30;
float lastPower[10] = {0,0,0,0,0,0,0,0,0,0};
int lastAngle[3] = {0,0,0};
//gyro-based PID turning
void PIDturnG(float pwr, int angle){
	int gIntegral = 0;
	int gDerivative = 0;
	int prevError = angle - SensorValue[gBase1];
	while(!(abs(angle - lastAngle[2]) <= 5 && abs(angle - SensorValue[gBase1]) <= 5) && lastPower[9] != gPower){
		int error = angle - SensorValue[gBase1];
		if(error == 0 || sgn(error*angle) == -1){
			gIntegral = 0;
		}
		if(gIntegral > 150000){
			gIntegral = 0;
		}
		gDerivative = error - prevError;
		prevError = error;
		gPower =  pwr * (gkP * error + gkI * gIntegral +  gkD * gDerivative);
		//if(abs(gPower) < 33 && abs(gPower) > 0) gPower = sgn(gPower)*33;
		lDrive(-PowerCap((int)gPower));
		rDrive(PowerCap((int)gPower));
		for(int p = 8; p >= 0; p--){
			lastPower[p+1] = lastPower[p];
		}
		for(int a = 1; a >= 0; a--){
			lastAngle[a+1] = lastAngle[a];
		}
		lastPower[0] = gPower;
		lastAngle[0] = SensorValue[gBase1];
		wait1Msec(20);
	}
	lDrive(0);
	rDrive(0);
	reset(0);
	gPower = 30;
	//https://www.vexforum.com/index.php/6465-a-pid-controller-in-robotc/0
}


void station1(){
	motor[mRollers] = 127;
}

void trickStation1(int angle){
	motor[mRollers] = 127;
	PIDturnG(.75, angle);
}

void station2Mogo(int angle){
	PIDturnG(.5, angle);
}

void station2Block(int angle){
	PIDturnG(.75, angle);
}

void stationLeft(){
	station1();
}

void stationMogoLeft(){
	station1();
	station2Mogo(900);
}

void stationBlockLeft(){
	station1();
	station2Block(x);
}

void stationRight(){
	station1();
}

void stationMogoRight(){
	station1();
	station2Mogo(-900);
}

void stationBlockRight(){
	station1();
	station2Block(x);
}

void trickStationLeft(){
	trickStation1(-900);
}

void trickStationMogoLeft(){
	trickStation1(-900);
	station2Mogo(900);
}

void trickStationBlockLeft(){
	trickStation1(-900);
	station2Block(x);
}

void trickStationRight(){
	trickStation1(900);
}

void trickStationMogoRight(){
	trickStation1(900);
	station2Mogo(-900);
}

void trickStationBlockRight(){
	trickStation1(900);
	station2Block(x);
}

void threeCone(int pwr, int dis){
	motor[mRollers] = 127;
	startTask(mogoDown);
	driveMobile(127,1500);
	motor[mRollers] = rollerPassive;
	startTask(mogoUp);
	waitUntil(mogoDone);
	dr4b(127, 3300);
	startTask(coneOut);
	drive(90,150);
	waitUntil(coneDone);
	motor[mRollers] = 127;
	startTask(fourBarDown);
	dr4b(127,3400);
	motor[mLift] = -127;
	motor[m4Bar] = -127;
	wait1Msec(500);
	motor[mRollers] = 50;
	motor[mLift] = 0;
	startTask(fourBarUp);
	waitUntil(fourBarDone);
	startTask(coneOut);
	dr4b(100,3300);
	/*startTask(fourBarDown);
	drive(90,135);
	dr4b(100,3300);
	motor[mRollers] = 127;
	startTask(fourBarDown);
	dr4b(100,3400);
	motor[mLift] = -127;
	motor[m4Bar] = -127;
	wait1Msec(400);
	motor[mRollers] = 50;
	dr4b(100,2400);
	startTask(fourBarUp);
	drive(pwr,dis);
	dr4b(100,2350);
	startTask(coneOut);*/
}

void mogo20Left3(){
	threeCone(127, -1400);
	PIDturnG(0.75,450);
	drive(85,-450);
	PIDturnG(0.75,900);
	driveTime(127,700,2750);
	startTask(mogoDown);
	waitUntil(mogoDone);
	startTask(mogoUp);
	drive(127, -500);
}

void mogo10Left3(){
	threeCone(127, -1400);
	PIDturnG(0.5, 1500);
	driveTime(75,100, 750);
	startTask(mogoDown);
	waitUntil(mogoDone);
	drive(127,-2250);
	PIDturnG(0.5, 800);
}

void mogo5Left3(){
	threeCone(127, -1100);
	PIDturnG(0.5, 1350);
	drive(90, -150);
	dr4b(127,2500);
	startTask(mogoDown);
	waitUntil(mogoDone);
	drive(127,-1500);
	PIDturnG(0.5, 900);
}

void mogo20Right3(){
	threeCone(127, -1300);
	PIDturnG(0.5,1400);
	drive(85,450);
	PIDturnG(0.5,900);
	driveTime(127,700, 2750);
	startTask(mogoDown);
	waitUntil(mogoDone);
	startTask(mogoUp);
	drive(127, -500);
}

void mogo10Right3(){
	threeCone(127, -1100);
	PIDturnG(0.5, 2250);
	driveTime(75,100, 750);
	startTask(mogoDown);
	waitUntil(mogoDone);
	drive(127,-500);
	PIDturnG(0.5, -200);
	drive(127,-1000);
	PIDturnG(0.5, -1000);
}

void mogo5Right3(){
	threeCone(127, -1100);
	PIDturnG(0.5, 2250);
	drive(90, -150);
	startTask(mogoDown);
	waitUntil(mogoDone);
	drive(127,-1500);
	PIDturnG(0.5, -900);
}

void trick20Left3(){
	motor[mRollers] = 127;
	drive(75,50);
	PIDturnG(0.75, 900);
	mogo20Left3();
}

void trick10Left3(){
	motor[mRollers] = 127;
	drive(75,50);
	PIDturnG(0.75, 900);
	mogo10Left3();
}

void trick5Left3(){
	motor[mRollers] = 127;
	drive(75,50);
	PIDturnG(0.75, 900);
	mogo5Left3();
}

void trick20Right3(){
	motor[mRollers] = 127;
	drive(75,50);
	PIDturnG(0.75, -900);
	mogo20Right3();
}

void trick10Right3(){
	motor[mRollers] = 127;
	drive(75,50);
	PIDturnG(0.75, -900);
	mogo10Right3();
}

void trick5Right3(){
	motor[mRollers] = 127;
	drive(75,50);
	PIDturnG(0.75, -900);
	mogo5Right3();
}

void twoCone(int pwr, int dis){
	motor[mRollers] = 127;
	startTask(mogoDown);
	driveMobile(127,1500);
	motor[mRollers] = rollerPassive;
	startTask(mogoUp);
	waitUntil(mogoDone);
	dr4b(100,2300);
	startTask(coneOut);

	drive(90,195);
	motor[mRollers] = 127;
	startTask(fourBarDown);
	dr4b(127,2300);
	motor[mLift] = -127;
	motor[m4Bar] = -127;
	wait1Msec(400);
	motor[mRollers] = 50;
	motor[mLift] = 0;
	startTask(fourBarUp);
	drive(pwr, dis);
	dr4b(100,2300);
	startTask(coneOut);
}

void mogo20Left2(){
	twoCone(127,-1000);
	PIDturnG(0.7,450);
	drive(85,-550);
	PIDturnG(0.7,900);
	driveTime(127,900,2650);
	startTask(mogoDown);
	waitUntil(mogoDone);
	startTask(mogoUp);
	drive(127, -500);
}

void mogo10Left2(){
	twoCone(127, -1300);
	PIDturnG(0.5, 1500);
	driveTime(75,100, 750);
	startTask(mogoDown);
	waitUntil(mogoDone);
	drive(127,-2250);
	PIDturnG(0.5, 800);
}

void mogo5Left2(){
	twoCone(127,-1100);
	PIDturnG(0.5, 1350);
	drive(90, -100);
	dr4b(127,2500);
	startTask(mogoDown);
	waitUntil(mogoDone);
	drive(127,-1500);
	PIDturnG(0.5, 900);
}

void mogo20Right2(){
	twoCone(127,-1200);
	PIDturnG(0.5,1400);
	drive(85,450);
	PIDturnG(0.5,900);
	drive(127,-100);
	driveTime(127,900, 2750);
	startTask(mogoDown);
	waitUntil(mogoDone);
	startTask(mogoUp);
	drive(127, -500);
}

void mogo10Right2(){
	twoCone(127,-1000);
	PIDturnG(0.5, 2250);
	driveTime(75,100, 750);
	startTask(mogoDown);
	waitUntil(mogoDone);
	drive(127,-500);
	PIDturnG(0.5, -200);
	drive(127,-1000);
	PIDturnG(0.5, -1000);
}

void mogo5Right2(){
	twoCone(127, -1100);
	PIDturnG(0.5, 2250);
	drive(90, -100);
	startTask(mogoDown);
	waitUntil(mogoDone);
	drive(127,-1500);
	PIDturnG(0.5, -900);
}

void trick20Left2(){
	motor[mRollers] = 127;
	drive(75,50);
	PIDturnG(0.75, 900);
	mogo20Left2();
}

void trick10Left2(){
	motor[mRollers] = 127;
	drive(75,50);
	PIDturnG(0.75, 900);
	mogo10Left2();
}

void trick5Left2(){
	motor[mRollers] = 127;
	drive(75,50);
	PIDturnG(0.75, 900);
	mogo5Left2();
}

void trick20Right2(){
	motor[mRollers] = 127;
	drive(75,50);
	PIDturnG(0.75, -900);
	mogo20Right2();
}

void trick10Right2(){
	motor[mRollers] = 127;
	drive(75,50);
	PIDturnG(0.75, -900);
	mogo10Right2();
}

void trick5Right2(){
	motor[mRollers] = 127;
	drive(75,50);
	PIDturnG(0.75, -900);
	mogo5Right2();
}

void pragmaSkills(){

}

void autonTest(){
	startTask(mogoDown);
}

void autonSelecter(){
	autonRead();
	switch(autonNumber){
	case 0: //test
		autonTest();
		break;
	case 2: //mogo 20 left 3
		mogo20Left3();
		break;
	case 3: //trick 20 left 3
		trick20Left3();
		break;
	case 4: //mogo 10 left 3
		mogo10Left3();
		break;
	case 5://trick 10 left 3
		trick10Left3();
		break;
	case 6://mogo 5 left 3
		mogo5Left3();
		break;
	case 7://trick 5 left 3
	trick5Left3();
		break;
	case 8://station mogo left
		stationMogoLeft();
		break;
	case 9://trick station mogo left
		trickStationMogoLeft();
		break;
	case 10://station block left
		stationBlockLeft();
		break;
	case 11://trick station block left
	trickStationBlockLeft();
		break;

	case 18: //mogo 20 right 3
		mogo20Right3();
		break;
	case 19: //trick 20 right 3
		trick20Right3();
		break;
	case 20: //mogo 10 right 3
		mogo10Right3();
		break;
	case 21: //trick 10 right 3
		trick10Right3();
		break;
	case 22: //mogo 5 right 3
		mogo5Right3();
		break;
	case 23: //trick 5 right 3
		trick5Right3();
		break;
	case 24: //station mogo right
		stationMogoRight();
		break;
	case 25: //trick station mogo right
		trickStationMogoRight();
		break;
	case 26: //station block right
		stationBlockRight();
		break;
	case 27: //trick station block right
		trickStationBlockRight();
		break;

	case 34: //mogo 20 left 2
		mogo20Left2();
		break;
	case 35: //trick 20 left 2
		trick20Left2();
		break;
	case 36: //mogo 10 left 2
	mogo10Left2();
		break;
	case 37: //trick 10 left 2
		trick10Left2();
		break;
	case 38: //mogo 5 left 2
		mogo5Left2();
		break;
	case 39: //trick 5 left 2
		trick5Left2();
		break;
	case 40: //just staion left
		stationLeft();
		break;
	case 41: //trick just station left
		trickStationLeft();
		break;

	case 50: //mogo 20 right 2
		mogo20Right2();
		break;
	case 51: //trick 20 right 2
		trick20Right2();
		break;
	case 52: //mogo 10 right 2
		mogo10Right2();
		break;
	case 53: //trick 10 right  2
		trick10Right2();
		break;
	case 54: //mogo 5 right 2
		mogo5Right2();
		break;
	case 55: //trick 5 right 2
		trick5Right2();
		break;
	case 56: //just staion right
		stationRight();
		break;
	case 57: //trick just station right
		trickStationRight();
		break;

	case 63: //pragma skills
		pragmaSkills();
		break;
	default:
		break;
	}
}

void pre_auton(){
	bStopTasksBetweenModes = true;
}

task autonomous(){
	autonNumber = 0;
	reset(23);
	reset(4);
	autonSelecter();
}
